**This is an explanation page**
Decision:
Use SonarQube
Use Spring (Java), Flask (Python)

## Tech Stack

비슷한 프레임워크 비교 후 각 프레임워크의 장단점 및 각 프레임워크를 우리 프로젝트에 선택하게 된 이유에 대해 서술하기

### Backend

<aside>
💡

고려 요소: Scalability, Business requirements, Community and support, Documentation, Performance, Flexibility, Third-party integrations, Time to market

</aside>

- 각 기능별 적합한 기술
    
    
    | **카테고리** | **기능** | **추천 기술** | **주요 장점** |
    | --- | --- | --- | --- |
    | 계정 | 로그인, 회원가입, 프로필 관리 | Java + Spring Boot | - Spring Security를 통한 강력한 인증 및 권한 관리
    - OAuth2 지원으로 소셜 로그인 구현 용이
    - JPA를 이용한 효율적인 데이터베이스 관리 |
    | 메인화면 | 네비게이션바, 계정 정보 표시 | Python + Django | - 빠른 프로토타이핑과 개발 속도
    - 관리자 페이지 자동 생성- 템플릿 엔진을 통한 동적 UI 구현 용이 |
    | 타로 - 목록 및 방 | 방 목록, 생성, 상세 페이지, 타로 화면 | Python + FastAPI | - 비동기 처리로 실시간 업데이트에 적합- 높은 성능으로 다수의 동시 접속 처리 가능
    - OpenAPI 문서 자동 생성 |
    | AI 타로 챗봇 | 챗봇 인터페이스 | Python + Flask | - 머신러닝 라이브러리와의 쉬운 통합
    - 경량화된 프레임워크로 AI 모델 서빙에 적합
    - 유연한 구조로 챗봇 로직 구현 용이 |
    | 채팅 | 사용자 간 채팅 기능 | Java + Spring WebSocket | - 실시간 양방향 통신 지원- 확장성이 뛰어나 대규모 채팅 시스템 구축 가능
    - STOMP 프로토콜 지원으로 복잡한 메시징 구현 용이 |
    | 결과 시각화 및 저장 | 타로 결과 시각화 문서 제공 | Python + Django | - 데이터 처리 및 시각화 라이브러리와의 쉬운 통합
    - ORM을 통한 효율적인 데이터 저장 및 관리
    - 템플릿 엔진을 이용한 동적 문서 생성 용이 |
    | 소셜 | 팔로우, 리뷰 기능 | Java + Spring Boot | - JPA를 이용한 복잡한 관계 모델링 용이
    - 트랜잭션 관리를 통한 데이터 일관성 보장
    - RESTful API 구현을 위한 강력한 지원 |
    
    **Java + Spring Boot와 Python + Flask 조합**
    
    Java + Spring Boot:
    
    - 계정 관리, 인증, 권한 부여 등 보안 관련 기능
    - 복잡한 비즈니스 로직 처리
    - 데이터베이스 관리 및 ORM (JPA 사용)
    - 실시간 채팅 기능 (WebSocket 사용)
    - 소셜 기능 (팔로우, 리뷰 등)
    
    Python + Flask:
    
    - AI 타로 챗봇 구현
    - 데이터 처리 및 분석
    - 결과 시각화
    - 빠른 프로토타이핑이 필요한 기능
    
    이 조합의 장점:
    
    1. 각 언어와 프레임워크의 강점을 활용할 수 있습니다.
    2. 마이크로서비스 아키텍처를 적용하기 용이합니다.
    3. 팀의 기술 스택 다양성을 높일 수 있습니다.
    
    주의할 점:
    
    1. 두 시스템 간의 통합 및 데이터 일관성 유지에 주의해야 합니다.
    2. 개발 및 배포 프로세스가 복잡해질 수 있습니다.
    3. 팀 멤버들이 두 기술 스택을 모두 이해해야 할 수도 있습니다.

- **Flask vs FastAPI**
    
    # Flask vs FastAPI: AI 서비스 구축 관점 비교
    
    ## Flask
    
    ### 장점
    
    - **간단하고 가벼움**: 초보자도 쉽게 시작할 수 있는 단순한 구조
    - **유연성**: 개발자가 원하는 대로 구조를 설계할 수 있음
    - **광범위한 커뮤니티와 풍부한 확장 기능**
    
    ### 단점
    
    - 비동기 처리가 기본적으로 지원되지 않음
    - 대규모 애플리케이션에서는 구조화에 더 많은 노력이 필요
    - 타입 힌팅이 기본적으로 제공되지 않음
    
    ## FastAPI
    
    ### 장점
    
    - **빠른 성능**: 비동기 처리를 기본적으로 지원
    - **자동 문서화**: Swagger UI와 ReDoc을 통한 API 문서 자동 생성
    - **타입 힌팅과 데이터 검증**: Pydantic을 이용한 강력한 타입 체크와 데이터 검증
    - **현대적인 Python 기능 활용**: 비동기 프로그래밍, 타입 힌팅 등
    
    ### 단점
    
    - 학습 곡선: 비동기 프로그래밍과 타입 시스템에 대한 이해가 필요
    - 상대적으로 새로운 프레임워크: Flask에 비해 커뮤니티와 리소스가 적음
    - 일부 레거시 시스템과의 통합이 어려울 수 있음
    
    ## AI 서비스 구축 관점
    
    - **Flask**: 간단한 AI 모델 서빙이나 프로토타이핑에 적합
    - **FastAPI**: 대규모 AI 서비스, 실시간 처리가 필요한 경우, 또는 복잡한 데이터 구조를 다루는 경우에 더 적합
    
    기능명세를 고려할 때, FastAPI가 더 적합할 것으로 보임.
    
    1. 실시간 처리: AI 타로 챗봇과 실시간 채팅 기능에 FastAPI의 비동기 처리 지원이 유용함.
    2. 복잡한 데이터 구조: 타로 카드 정보, 사용자 프로필, 방 정보 등 다양한 데이터 구조에 FastAPI의 Pydantic을 이용한 타입 체크와 데이터 검증 기능이 도움됨.
    3. API 문서화: 자동 문서화 기능으로 프론트엔드 개발자와의 협업이 용이함.
    4. 성능: 다수 사용자의 동시 접속을 고려할 때, FastAPI의 높은 성능이 중요함.
    5. 현대적인 Python 기능: 비동기 프로그래밍과 타입 힌팅으로 코드의 안정성과 가독성을 높일 수 있음.
    
    다만, FastAPI는 학습 곡선이 있어 팀의 기술 숙련도를 고려해야 함. 또한 프로젝트의 규모와 복잡성에 따라 선택을 달리할 수 있음.
    
    참고 : https://recording-it.tistory.com/112
    
- **Database**
    
    수직 확장 vs. 수평 확장
    
    ### **비교:**
    
    |  | **수직 확장** | **수평 확장** |
    | --- | --- | --- |
    | **확장 방법** | 서버에 리소스를 추가 (CPU, RAM, 디스크 등) | 서버 수를 늘려서 분산 처리 |
    | **성장 한계** | 성능에 한계가 있음 (하드웨어 한계) | 확장성에 제한이 적고 무제한으로 확장 가능 |
    | **유지보수** | 관리가 간단하고 설정이 직관적 | 서버 추가 및 관리가 복잡하고 분산 처리 필요 |
    | **장점** | 설정이 간단하고 서버 하나로 관리 가능 | 시스템의 확장성 및 내구성이 뛰어남 |
    | **단점** | 성능에 한계가 있고, 고비용의 하드웨어 필요 | 시스템 복잡성 증가, 데이터 일관성 문제 발생 가능 |
    
    ### **어떤 상황에서 어느 방식을 선택할까?**
    
    - **수직 확장**은 주로 작은 규모의 시스템이나 관리가 간단한 애플리케이션에 적합합니다. 초기에는 비용이 적고 간단하게 확장할 수 있지만, 성능 한계가 도달하면 어려움이 있을 수 있습니다.
    - **수평 확장**은 대규모 시스템에서 성능을 확장하고, 가용성과 내구성을 높이기 위해 사용됩니다. 클라우드 기반 서비스나 빅데이터 시스템에서 흔히 사용되며, 서버를 여러 대 추가하여 시스템을 확장합니다.
    
    | **특징** | **PostgreSQL** | **MongoDB** | **MySQL** | **NoSQL** |
    | --- | --- | --- | --- | --- |
    | **유형** | 관계형 데이터베이스 (RDBMS) | NoSQL (문서 기반 스토어) | 관계형 데이터베이스 (RDBMS) | 다양함 (예: 키-값, 문서, 열, 그래프 등) |
    | **데이터 모델** | 테이블 (행과 열) | JSON-like 문서 | 테이블 (행과 열) | 다양함 (예: 키-값, 그래프, 문서 등) |
    | **스키마** | 고정된 스키마 | 유연한 스키마 | 고정된 스키마 | 유연한 스키마 |
    | **확장성** | 수직 확장 (중간 규모 작업에 적합) | 수평 확장 (용이) | 수직 확장 | 수평 확장 (유형에 따라 다름) |
    | **ACID 준수** | 예 | 예 (버전 4.0부터 다중 문서 트랜잭션 지원) | 예 | 유형에 따라 다름 (일부는 최종 일관성) |
    | **주요 용도** | 복잡한 관계형 데이터 | 높은 트래픽, 유연한 데이터 | 웹 애플리케이션, 간단한 쿼리 | 대규모, 유연한 데이터, 분산형 시스템 |
    | **강점** | 복잡한 쿼리, 조인, 확장성 | 유연한 스키마, 확장성, 빠른 속도 | 설정 용이, 작은 규모에서 빠른 속도 | 수평 확장, 스키마 유연성, 빅 데이터 처리 |
    
    ### 요약:
    
    - **PostgreSQL:** 복잡한 관계형 데이터와 트랜잭션, 강력한 SQL 기능이 필요한 경우에 적합합니다.
    - **MongoDB:** 유연한 스키마와 확장성이 필요한 고속 읽기/쓰기를 요구하는 애플리케이션에 적합합니다.
    - **MySQL:** 간단하고 가벼운 관계형 데이터베이스를 사용하는 웹 애플리케이션에 적합합니다.
    - **NoSQL:** 대규모 분산 시스템, 비정형 및 반정형 데이터, 높은 확장성이 필요한 애플리케이션에 적합합니다.

    ### 벡터 데이터베이스란?

벡터 데이터베이스는 기본적으로 **벡터**(즉, 고차원 숫자 배열) 데이터를 저장하고 검색하는 데 특화된 데이터베이스입니다. 벡터는 일반적으로 **특징 벡터**(feature vector) 또는 **임베딩(embedding)**이라고 불리며, 이는 주로 머신러닝 알고리즘에서 데이터를 수치적인 형식으로 표현한 것입니다.

### 주요 개념

1. **벡터(Embedding):**
    - 벡터는 고차원의 실수 배열입니다. 예를 들어, 단어, 문장, 이미지 등은 AI 모델을 통해 고차원의 벡터로 변환됩니다. 이 벡터는 원래의 데이터의 **의미**나 **특징**을 압축해서 나타냅니다.
    - 예를 들어, 단어 "사과"는 Word2Vec, GloVe, BERT와 같은 모델을 통해 벡터로 변환되며, 이 벡터는 "사과"와 의미가 비슷한 단어들과 가까운 값을 가질 것입니다.

### 대표적인 벡터 데이터베이스

1. **Pinecone:**
    - Pinecone은 벡터 데이터베이스로, AI 및 ML 애플리케이션에 적합하게 설계된 완전 관리형 서비스입니다. 빠른 유사도 검색과 높은 확장성을 제공합니다.
2. **Weaviate:**
    - Weaviate는 오픈 소스 벡터 데이터베이스로, 다양한 머신러닝 모델과 통합이 가능하며, 벡터 검색과 함께 메타데이터 검색을 지원합니다.
3. **Faiss (Facebook AI Similarity Search):**
    - Faiss는 Facebook이 개발한 고속 근사 최근접 이웃 검색 라이브러리로, 대규모 벡터 데이터셋에서 유사도를 효율적으로 계산하는 데 사용됩니다. 주로 연구 및 프로덕션 환경에서 사용됩니다.
4. **Milvus:**
    - Milvus는 고성능 벡터 데이터베이스로, 특히 대규모 벡터 검색에 적합합니다. AI, 영상 인식, 추천 시스템 등에 사용됩니다.
5. **Chroma:**
    - Chroma는 개발자와 데이터 과학자들이 사용하기에 적합한 오픈 소스 벡터 데이터베이스로, NLP, 검색, 추천 시스템에 사용됩니다.

